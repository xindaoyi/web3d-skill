<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>硬件加速图形渲染示例</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ddd;
            margin: 10px 0;
        }
        .comparison {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison div {
            flex: 1;
        }
        h1, h2 {
            color: #333;
        }
        p {
            line-height: 1.6;
        }
        .highlight {
            background-color: #e7f3ff;
            padding: 15px;
            border-left: 4px solid #2196F3;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>硬件加速图形渲染解释</h1>
        
        <div class="highlight">
            <p><strong>硬件加速图形渲染</strong>是指利用计算机的图形处理单元（GPU）来执行图形计算和渲染任务，而不是仅仅依赖中央处理器（CPU）。</p>
        </div>

        <h2>GPU vs CPU 对比</h2>
        <div class="comparison">
            <div>
                <h3>CPU（中央处理器）</h3>
                <ul>
                    <li>少量强大核心（通常2-32个）</li>
                    <li>适合复杂串行计算</li>
                    <li>通用计算任务处理</li>
                    <li>不适合大规模并行任务</li>
                </ul>
            </div>
            <div>
                <h3>GPU（图形处理器）</h3>
                <ul>
                    <li>数百到数千个小核心</li>
                    <li>专为并行处理设计</li>
                    <li>专门处理图形计算</li>
                    <li>同时处理数百万顶点/像素</li>
                </ul>
            </div>
        </div>

        <h2>示例对比</h2>
        <p>以下是使用CPU软件渲染和GPU硬件加速渲染的对比：</p>
        
        <div class="comparison">
            <div>
                <h3>软件渲染（仅CPU）</h3>
                <canvas id="cpuCanvas" width="400" height="300"></canvas>
                <p>使用JavaScript在CPU上逐像素计算</p>
                <button id="cpuButton">开始CPU渲染</button>
                <p id="cpuTime"></p>
            </div>
            <div>
                <h3>硬件加速（GPU）</h3>
                <canvas id="gpuCanvas" width="400" height="300"></canvas>
                <p>使用WebGL在GPU上并行处理</p>
                <button id="gpuButton">开始GPU渲染</button>
                <p id="gpuTime"></p>
            </div>
        </div>

        <h2>硬件加速的优势</h2>
        <ul>
            <li><strong>性能</strong>：GPU可以同时处理数千个简单任务</li>
            <li><strong>效率</strong>：专用硬件执行特定任务更高效</li>
            <li><strong>并行性</strong>：适合处理图形渲染中的大规模并行计算</li>
            <li><strong>专用内存</strong>：GPU有专用的高速显存（VRAM）</li>
        </ul>

        <h2>WebGL中的硬件加速</h2>
        <p>WebGL是浏览器中使用硬件加速图形渲染的主要技术：</p>
        <ul>
            <li>直接与GPU通信</li>
            <li>使用着色器语言（GLSL）编写并行程序</li>
            <li>利用GPU的并行处理能力渲染复杂3D场景</li>
            <li>处理数百万个多边形和像素</li>
        </ul>
    </div>

    <script>
        // CPU软件渲染示例
        function softwareRender() {
            const startTime = performance.now();
            const canvas = document.getElementById('cpuCanvas');
            const ctx = canvas.getContext('2d');
            
            const width = canvas.width;
            const height = canvas.height;
            
            // 创建图像数据
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            // 软件渲染 - 逐像素计算（简化示例）
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    
                    // 简单的渐变计算
                    data[index] = (x / width) * 255;       // R
                    data[index + 1] = (y / height) * 255;  // G
                    data[index + 2] = 100;                 // B
                    data[index + 3] = 255;                 // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            const endTime = performance.now();
            document.getElementById('cpuTime').textContent = `渲染时间: ${(endTime - startTime).toFixed(2)} 毫秒`;
        }

        // GPU硬件加速渲染示例
        function hardwareRender() {
            const startTime = performance.now();
            const canvas = document.getElementById('gpuCanvas');
            const gl = canvas.getContext('webgl');
            
            if (!gl) {
                alert('无法初始化WebGL');
                return;
            }
            
            // 顶点着色器
            const vertexShaderSource = `
                attribute vec2 aPosition;
                varying vec2 vTexCoord;
                
                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                    vTexCoord = aPosition * 0.5 + 0.5;
                }
            `;
            
            // 片段着色器
            const fragmentShaderSource = `
                precision mediump float;
                varying vec2 vTexCoord;
                
                void main() {
                    gl_FragColor = vec4(vTexCoord.x, vTexCoord.y, 0.4, 1.0);
                }
            `;
            
            // 编译着色器
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            
            // 创建程序
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);
            
            // 定义顶点
            const vertices = new Float32Array([
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0
            ]);
            
            // 创建缓冲区
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            // 获取顶点属性位置
            const positionLocation = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // 设置视口和清空画布
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // 绘制
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            const endTime = performance.now();
            document.getElementById('gpuTime').textContent = `渲染时间: ${(endTime - startTime).toFixed(2)} 毫秒`;
        }

        // 绑定按钮事件
        document.getElementById('cpuButton').addEventListener('click', softwareRender);
        document.getElementById('gpuButton').addEventListener('click', hardwareRender);
        
        // 初始渲染
        window.addEventListener('load', () => {
            softwareRender();
            hardwareRender();
        });
    </script>
</body>
</html>